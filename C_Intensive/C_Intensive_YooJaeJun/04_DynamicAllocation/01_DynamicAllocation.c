#include <stdio.h>
#include <stdlib.h>
// standard library file
// C 언어 표준의 라이브러리 파일입니다.
// lib 파일의 의미
// 함수의 선언만을 제공하고 정의부를 공개하지 않는 파일

// 메모리 영역
// CodeArea
// 우리가 쓴 소스코드를 저장하는 영역입니다.
// 상수 데이터(숫자형 데이터)를 저장하는 공간입니다.
// 함수 데이터가 저장되는 공간

// DataArea
// 프로그램의 시작부터 끝날 때까지 남아있는 데이터들이 저장되는 공간
// 전역변수
// 정적변수

// HeapArea
// 사용자가 직접 관리하는 데이터 공간입니다.
// 해당 공간에 존재하는 모든 데이터는 사용자가 직접 공간을 만들어줘야 하며
// 해제도 사용자가 직접해줘야 합니다.
// 동적할당 : 사용자가 직접 할당한 공간
// 런타임 시간에 할당됩니다.

// StackArea
// 잠깐 할당되었다가 사라지는 데이터들이 존재하는 공간
// 매개변수
// 지역변수


// 컴파일 타임: 컴파일러가 우리가 쓴 소스코드를 이진코드로 변환하는 시간입니다.
// 런 타임: 프로그램이 동작하고 있는 시간입니다.


// 동적할당 (Dynamic Allocation)
// 컴퓨ㅓ가 알아서 만들어주는 것이 아닌 
// 런타임 시간에 사용자가 직접 공간을 할당하는 것을 의미합니다.
// C 언어의 동적할당은 malloc, calloc, realloc 함수들을 통해서
// 할당이 가능하며, 동적할당은 사용자가 해제하기 전까지
// 남아있는 메모리공간이므로 할 일을 마쳤다면 반드시 해제해주는 게 좋습니다.
// 동적할당한 메모리를 해제할 땐 free 함수를 사용합니다.


int main()
{
	// void* malloc(size)
	// stdlib.h 를 추가해야 사용할 수 있습니다.
	// size Byte 만큼의 메모리공간을 동적할당하고
	// 할당한 메모리공간의 주소를 반환합니다.
	// 어떤 데이터를 저장할지 모르므로 void* 형태를 반환합니다.
	// - void* : 데이터의 식별자(자료형)가 없는 공간의 주소를 뜻합니다.
	//			간접참조를 하지 못합니다.
	
	// 100,1001,0011,1110,0000
	// 1001,0010,0111,1100 <- 까지 밖에 못읽음 ,000

	// int A = 300000;
	// short* p = &A;
	// printf("%d \n", *p);

	// int A = 10;
	// int* p = &A;
	int* p = (int*)malloc(4);
	// (int*) : 특정 값을  int* 형태로 변환합니다.
	// (DataType) : 강제적 캐스팅 연산자
	// 기존의 자료형을 DataType 으로 바꿉니다.

	printf("동적할당한 메모리 공간의 주소 : %p \n", p);
	// malloc으로 동적할당한 공간은 초기화하지 않는다면 쓰레기값이 들어갑니다.
	printf("동적할당한 메모리 공간에 들어있는 값 : %i \n", *p);
	*p = 10;
	printf("동적할당한 메모리 공간에 들어있는 값 : %i \n", *p);

	// 동적할당한 공간은 사용이 끝난다면 꼭 해제해야줘야 합니다.
	// 사용하지 않는 공간이 많아질 경우 메모리 누수가 발생합니다.
	// free 함수를 사용하여 해제합니다.
	// free(address) : 해당 동적할당한 주소공간을 해제합니다.
	free(p);
	printf("p가 가리키는 주소 : %p \n", p);
	p = NULL;
	// 동적할당한 공간을 해제하여도 포인터 변수에는 주소를 저장하고 있기 때문에
	// 다른 포인터들이 새로 동적할당한 공간을 가리킬 수도 있습니다.
	// 존재하지도 않는 공간의 주소를 저장하는 포인터를 댕글링 포인터라 합니다.
	// 원하지 않는 간접 접근을 막기 위해서 해제 후 NULL 로 초기화해줘야 합니다.
	printf("null 이후 p가 가리키는 주소 : %p \n", p);
	// NULL : 0 입니다.
	// 주소값이 0 이라는 뜻은 아무것도 가르키지 않겠다 라는 것을 뜻합니다.
	// 컴퓨터는 시작주소를 0으로 절대 할당하지 않습니다.
	
	return 0;
}
